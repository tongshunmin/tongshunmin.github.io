---
layout: post
title: openssl源代码结构
category: Linux
tags: Linux
keywords: dll,lib
description: 
---

## 引言
---
>    openssl源代码主要由eay库、ssl库、工具源码、范例源码以及测试源码组成。

## eay库
---
    eay库是基础的库函数，提供了很多功能。源代码放在crypto目录下。包括如下内容：
    
    1） asn.1 DER编码解码(crypto/asn1目录)，它包含了基本asn1对象的编解码以及数字证书请求、数字证书、CRL撤销列表以及PKCS8等最基本的编解码函数。这些函数主要通过宏来实现。
    
    2） 抽象IO(BIO,crypto/bio目录)，本目录下的函数对各种输入输出进行抽象，包括文件、内存、标准输入输出、socket和SSL协议等。
    
    3） 大数运算(crypto/bn目录)，本目录下的文件实现了各种大数运算。这些大数运算主要用于非对称算法中密钥生成以及各种加解密操作。另外还为用户提供了大量辅助函数，比如内存与大数之间的相互转换。
    
    4） 字符缓存操作(crypto/buffer目录)。
    
    5） 配置文件读取(crypto/conf目录)，openssl主要的配置文件为openssl.cnf。本目录下的函数实现了对这种格式配置文件的读取操作。
    
    6） DSO(动态共享对象,crypto/dso目录)，本目录下的文件主要抽象了各种平台的动态库加载函数，为用户提供统一接口。
    
    7） 硬件引擎(crypto/engine目录)，硬件引擎接口。用户如果要写自己的硬件引擎，必须实现它所规定的接口。
    
    8） 错误处理(crypto/err目录)，当程序出现错误时，openssl能以堆栈的形式显示各个错误。本目录下只有基本的错误处理接口，具体的的错误信息由各个模块提供。各个模块专门用于错误处理的文件一般为*_err..c文件。
    
    9） 对称算法、非对称算法及摘要算法封装(crypto/evp目录)。
    
    10） HMAC(crypto/hmac目录)，实现了基于对称算法的MAC。
    
    11） hash表(crypto/lhash目录)，实现了散列表数据结构。openssl中很多数据结构都是以散列表来存放的。比如配置信息、ssl session和asn.1对象信息等。
    
    12） 数字证书在线认证(crypto/ocsp目录)，实现了ocsp协议的编解码以及证书有效性计算等功能。
    
    13） PEM文件格式处理(crypto/pem)，用于生成和读取各种PEM格式文件，包括各种密钥、数字证书请求、数字证书、PKCS7消息和PKCS8消息等。
    
    14） pkcs7消息语法(crypto/pkcs7目录)，主要实现了构造和解析PKCS7消息；
    
    15） pkcs12个人证书格式(crypto/pckcs12目录)，主要实现了pkcs12证书的构造和解析。
    
    16） 队列(crypto/pqueue目录)，实现了队列数据结构，主要用于DTLS。
    
    17） 随机数(crypto/rand目录)，实现了伪随机数生成，支持用户自定义随机数生成。
    
    18） 堆栈(crypto/stack目录)，实现了堆栈数据结构。
    
    19） 线程支持(crypto/threads)，openssl支持多线程，但是用户必须实现相关接口。
    
    20） 文本数据库(crypto/txt_db目录)。
    
    21） x509数字证书(crypto/x509目录和crypto/x509v3)，包括数字证书申请、数字证书和CRL的构造、解析和签名验证等功能了；
    
    22） 对称算法(crypto/aes、crypto/bf、crypto/cast、ccrypto/omp和crypto/des等目录)。
    
    23） 非对称算法(crypto/dh、crypto/dsa、crypto/ec和crypto/ecdh)。
    
    24） 摘要算法(crypto/md2、crypto/md4、crypto/md5和crypto/sha)以及密钥交换/认证算法(crypto/dh 和crypto/krb5)。
    
    ssl库所有源代码在ssl目录下，包括了sslv2、sslv3、tlsv1和DTLS的源代码。各个版本基本上都有客户端源码(*_clnt.c)、服务源码(*_srvr.c)、通用源码(*_both.c)、底层包源码（*_pkt.c）、方法源码(*_meth.c)以及协议相关的各种密钥计算源码(*_enc.c)等，都很有规律。
    
    工具源码主要在crypto/apps目录下，默认编译时只编译成openssl(windows下为openssl.exe)可执行文件。该命令包含了各种命令工具。此目录下的各个源码可以单独进行编译。
    
    范例源码在demo目录下，另外engines目录给出了openssl支持的几种硬件的engines源码，也可以作为engine编写参考。
    
    测试源码主要在test目录下。

## SSL库
---
    SSL是Secure Socket Layer（安全套接层协议）的缩写,目标是保证两个应用间通信的保密性和可靠性,可在服务器端和用户端同时实现支持。改协议能使用户/服务器应用之间的通信不被攻击者窃听，并且始终对服务器进行认证，还可选择对用户进行认证。 
    OpenSSL整个软件包大概可以分成三个主要的功能部分：密码算法库、SSL协议库以及应用程序。OpenSSL的目录结构自然也是围绕这三个功能部分进行规划的。 
    加密算法：对称加密 非对称加密 信息摘要算法 密钥和协议管理 SSL和TSL协议。 
    对称算法使用一个密钥。给定一个明文和一个密钥，加密产生密文，其长度和明文大致相同。解密时，使用密钥与加密密钥相同。 

    对称算法主要有四种加密模式： 

        (1) 电子密码本模式 Electronic Code Book(ECB) 

        这种模式是最早采用和最简单的模式，它将加密的数据分成若干组，每组的大小跟加密密钥长度相同，然后每组都用相同的密钥进行加密。 

        其缺点是：电子编码薄模式用一个密钥加密消息的所有块，如果原消息中重复明文块，则加密消息中的相应密文块也会重复，因此，电子编码薄模式适于加密小消息。 

        （2）加密块链模式 Cipher Block Chaining(CBC) 

        CBC模式的加密首先也是将明文分成固定长度的块，然后将前面一个加密块输出的密文与下一个要加密的明文块进行异或操作，将计算结果再用密钥进行加密得到密文。第一明文块加密的时候，因为前面没有加密的密文，所以需要一个初始化向量。跟ECB方式不一样，通过连接关系，使得密文跟明文不再是一一对应的关系，破解起来更困难，而且克服了只要简单调换密文块可能达到目的的攻击。 

        （3）加密反馈模式 Cipher Feedback Mode(CFB) 

        面向字符的应用程序的加密要使用流加密法，可以使用加密反馈模式。在此模式下，数据用更小的单元加密，如可以是8位，这个长度小于定义的块长（通常是64位）。其加密步骤是： 

        a） 使用64位的初始化向量。初始化向量放在移位寄存器中，在第一步加密，产生相应的64位初始化密文； 
        b)  始化向量最左边的8位与明文前8位进行异或运算，产生密文第一部分（假设为c），然后将c传输到接收方； 
        c)  向量的位（即初始化向量所在的移位寄存器内容）左移8位，使移位寄存器最右边的8位为不可预测的数据，在其中填入c的内容； d) 第1-3步，直到加密所有的明文单元。
        解密过程相反 

        4）输出反馈模式 Output Feedback Mode(OFB) 

        输出反馈模式与CFB相似，惟一差别是，CFB中密文填入加密过程下一阶段，而在OFB中，初始化向量加密过程的输入填入加密过程下一阶段。 

        摘要算法是一种能产生特殊输出格式的算法，这种算法的特点是：无论用户输入什么长度的原始数据，经过计算后输出的密文都是固定长度的，这种算法的原理是根据一定的运算规则对原数据进行某种形式的提取，这种提取就是摘要，被摘要的数据内容与原数据有密切联系，只要原数据稍有改变，输出的“摘要”便完全不同，因此，基于这种原理的算法便能对数据完整性提供较为健全的保障。但是，由于输出的密文是提取原数据经过处理的定长值，所以它已经不能还原为原数据，即消息摘要算法是不可逆的，理论上无法通过反向运算取得原数据内容，因此它通常只能被用来做数据完整性验证。 

        如今常用的“消息摘要”算法经历了多年验证发展而保留下来的算法已经不多，这其中包括MD2、MD4、MD5、SHA、SHA-1/256/383/512等。 

        常用的摘要算法主要有MD5和SHA1。D5的输出结果为16字节，sha1的输出结果为20字节。 

        在公钥密码系统中，加密和解密使用的是不同的密钥，这两个密钥之间存在着相互依存关系：即用其中任一个密钥加密的信息只能用另一个密钥进行解密。这使得通信双方无需事先交换密钥就可进行保密通信。其中加密密钥和算法是对外公开的，人人都可以通过这个密钥加密文件然后发给收信者，这个加密密钥又称为公钥；而收信者收到加密文件后,它可以使用他的解密密钥解密，这个密钥是由他自己私人掌管的，并不需要分发，因此又成称为私钥 


    应用程序：主要包括密钥生成、证书管理、格式转换、数据加密和签名、SSL测试以及其它辅助配置功能。 
    Engine机制目的是为了使OpenSSL能够透明地使用第三方提供的软件加密库或者硬件加密设备进行加密。 
    BIO机制是OpenSSL提供的一种高层IO接口，该接口封装了几乎所有类型的IO接口，如内存访问、文件访问以及Socket等。这使得代码的重用性大幅度提高，OpenSSL对于随机数的生成和管理也提供了一整套的解决方法和支持API函数。

感谢收看，如果对大家有帮助，请[github上follow和star](https://github.com/tongshunmin)，本文发布在[佟顺民的技术博客](http://blog.mineki.cn/)，转载请注明出处

##  参考
使用 DEF 文件从 DLL 导出
[Module-Definition (.Def) Files](http://my.oschina.net/hondfy/blog/165675)


